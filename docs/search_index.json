[["The-Unix-Command-Line.html", "The Linux Command Line Notes Welcome Chapter 1 What Is the Shell? Simple Commands Ending a Terminal Session Chapter 2 Navigation Current Working Directory Listing Directory Contents Changing the Current Working Directory Chapter 3 Exploring the System Having More Fun with ls Common ls Options Determining a File’s Type with file Viewing File Contents with less less Commands Directories Found on Linux Systems Chapter 4 Manipulating Files and Directories Wildcards mkdir - Create Directories cp – Copy Files and Directories mv – Move and Rename Files rm – Remove Files and Directories ln – Create Links Chapter 5 Working with Commands What Exactly Are Commands? Identifying Commands Getting a Command’s Documentation Creating Our Own Commands with alias Chapter 6 Redirection Redirecting Standard Output Redirecting Standard Error Redirecting Standard Input Pipelines Chapter 7 See the World as the Shell Sees It Chapter 8 Advanced Keyboard Tricks Chapter 9 Permissions References", " The Linux Command Line Notes Welcome Directories Found on Linux Systems Chapter 1 What Is the Shell? “When we speak of the command line, we are really referring to the shell. The shell is a program that takes keyboard commands and passes them to the operating system to carry out. Almost all Linux distributions supply a shell program from the GNU Project called bash. The name “bash” is an acronym for “Bourne Again SHell,” a reference to the fact bash is an enhanced replacement for sh, the original Unix shell program written by Steve Bourne.\" (Shotts 2019) Simple Commands Date Display the current time and date date: $ date Thu Mar 8 15:09:41 EST 2018 Calendar Display a calendar of the current month $ cal February 2021 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Disk Drives To see the current amount of free space on our disk drives, enter df. $ df Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 1512552 0 1512552 0% /dev tmpfs 1528228 0 1528228 0% /dev/shm tmpfs 1528228 8692 1519536 1% /run tmpfs 1528228 0 1528228 0% /sys/fs/cgroup /dev/sda1 35634176 4182988 31451188 12% / /dev/sda3 33796768 49176 32001112 1% /backup tmpfs 305644 4 305640 1% /run/user/1001 Likewise, to display the amount of free memory, enter the free command. $ free total used free shared buff/cache available Mem: 3056460 205784 2656980 8760 193696 2689788 Swap: 3145724 0 3145724 Ending a Terminal Session Entering exit in the cammand prompt or by pressing Ctrl+d $ exit Chapter 2 Navigation pwd – Print name of current working directory ls – List directory contents cd – Change directory Current Working Directory To print the path of the current working directory, use pwd. $ pwd /home/kelly Listing Directory Contents To list the contents of a directory, use ls. $ cd / $ ls backup boot etc lib media opt root sbin sys usr bin dev home lib64 mnt proc run srv tmp var Changing the Current Working Directory Absolute Pathnames: represented by the leading slash in the pathname Ex. /usr/bin Relative Pathnames: starts from the working directory “.”: refers to the working directory “..” the working directory’s parent directory To change the current working directory, use cd. $ cd /home/kelly $ pwd /home/kelly Some Helpful Shortcuts Shortcut Result cd Changes the working directory to your home directory. cd - Changes the working directory to the previous working directory. cd ~user_name Changes the working directory to the home directory of user_name. For example, cd ~bob will change the directory to the home directory of user “bob.” Important Facts About Filenames Filenames that begin with a period character are hidden. This only means that ls will not list them unless you say ls -a. Filenames and commands in Linux, like Unix, are case sensitive. Linux has no concept of a “file extension” like some other operating systems. You may name files any way you like. The contents and/or purpose of a file is determined by other means. Although Unix-like operating systems don’t use file extensions to determine the contents/purpose of files, many application programs do. Though Linux supports long filenames that may contain embedded spaces and punctuation characters, limit the punctuation characters in the names of files you create to period, dash, and underscore. Most importantly, do not embed spaces in filenames. If you want to represent spaces between words in a filename, use underscore characters. You will thank yourself later. (Shotts 2019) Chapter 3 Exploring the System ls – List directory contents file – Determine file type less – View file contents Having More Fun with ls List multiple directories $ ls ~ ./Desktop Change the format of the output to reveal more detail. $ ls -l the l option to produce long format output, and the t option to sort the result by the file’s modification time $ ls -lt add the long option “–reverse” to reverse the order of the sort. $ ls -lt --reverse Note that command options, like filenames in Linux, are case-sensitive. Common ls Options Option Long Option Description -a --all List all files, even those with names that begin with a period, which are normally not listed (that is, hidden). -A --almost-all Like the -a option above except it does not list . (current directory) and .. (parent directory). -d --directory Ordinarily, if a directory is specified, ls will list the contents of the directory, not the directory itself. Use this option in conjunction with the -l option to see details about the directory rather than its contents. -F --classify This option will append an indicator character to the end of each listed name. For example, a forward slash (/) if the name is a directory. -h --human-readable In long format listings, display file sizes in human readable format rather than in bytes. -l Display results in long format. -r --reverse Display the results in reverse order. Normally, ls displays its results in ascending alphabetical order. -S Sort results by file size. -t Sort by modification time. Determining a File’s Type with file $ file picture.jpg picture.jpg: JPEG image data, JFIF standard 1.01 Viewing File Contents with less The less command is a program to view text files. Throughout our Linux system, there are many files that contain human-readable text. The less program provides a convenient way to examine them. What Is “Text?” There are many ways to represent information on a computer. All methods involve defining a relationship between the information and some numbers that will be used to represent it. Computers, after all, only understand numbers and all data is converted to numeric representation. Some of these representation systems are very complex (such as compressed video files), while others are rather simple. One of the earliest and simplest is called ASCII text. ASCII (pronounced “As-Key”) is short for American Standard Code for Information Interchange. This is a simple encoding scheme that was first used on Teletype machines to map keyboard characters to numbers. Text is a simple one-to-one mapping of characters to numbers. It is very compact. Fifty characters of text translates to fifty bytes of data. It is important to understand that text only contains a simple mapping of characters to numbers. It is not the same as a word processor document such as one created by Microsoft Word or LibreOffice Writer. Those files, in contrast to simple ASCII text, contain many non-text elements that are used to describe its structure and formatting. Plain ASCII text files contain only the characters themselves and a few rudimentary control codes such as tabs, carriage returns and line feeds. Throughout a Linux system, many files are stored in text format and there are many Linux tools that work with text files. Even Windows recognizes the importance of this format. The well-known NOTEPAD.EXE program is an editor for plain ASCII text files. Why would we want to examine text files? Because many of the files that contain system settings (called configuration files) are stored in this format, and being able to read them gives us insight about how the system works. In addition, some of the actual programs that the system uses (called scripts) are stored in this format. The less command is used like this: $ less filename less Commands Command Action Page Up or b Scroll back one page Page Down or space Scroll forward one page Up arrow Scroll up one line Down arrow Scrool down one line G Move to the end of the text 1G of g Move to the beginning of the text file /characters Search forward to the next occurrence of characters n Search for the next occurrence of the previous search h Display help screen q Quit less Directories Found on Linux Systems Directory Comments / The root directory. Where everything begins. /bin Contains binaries (programs) that must be present for the system to boot and run. /boot Contains the Linux kernel, initial RAM disk image (for drivers needed at boot time), and the boot loader. Interesting files: - /boot/grub/grub.conf or menu.lst, which are used to configure the boot loader.- /boot/vmlinuz (or something similar), the Linux kernel /dev This is a special directory that contains device nodes. “Everything is a file” also applies to devices. Here is where the kernel maintains a list of all the devices it understands. /etc The /etc directory contains all of the system-wide configuration files. It also contains a collection of shell scripts that start each of the system services at boot time. Everything in this directory should be readable text. Interesting files: While everything in /etc is interesting, here are some all-time favorites:- /etc/crontab, a file that defines when automated jobs will run.- /etc/fstab, a table of storage devices and their associated mount points.- /etc/passwd, a list of the user accounts. /home In normal configurations, each user is given a directory in /home. Ordinary users can only write files in their home directories. This limitation protects the system from errant user activity. /lib Contains shared library files used by the core system programs. These are similar to dynamic link libraries (DLLs) in Windows. /lost+found Each formatted partition or device using a Linux file system, such as ext4, will have this directory. It is used in the case of a partial recovery from a file system corruption event. Unless something really bad has happened to our system, this directory will remain empty. /media On modern Linux systems the /media directory will contain the mount points for removable media such as USB drives, CD-ROMs, etc. that are mounted automatically at insertion. /mnt On older Linux systems, the /mnt directory contains mount points for removable devices that have been mounted manually. /opt The /opt directory is used to install “optional” software. This is mainly used to hold commercial software products that might be installed on the system. /proc The /proc directory is special. It’s not a real file system in the sense of files stored on the hard drive. Rather, it is a virtual file system maintained by the Linux kernel. The “files” it contains are peepholes into the kernel itself. The files are readable and will give us a picture of how the kernel sees the computer. /root This is the home directory for the root account. /sbin This directory contains “system” binaries. These are programs that perform vital system tasks that are generally reserved for the superuser. /tmp The /tmp directory is intended for the storage of temporary, transient files created by various programs. Some configurations cause this directory to be emptied each time the system is rebooted. /usr The /usr directory tree is likely the largest one on a Linux system. It contains all the programs and support files used by regular users. /usr/bin /usr/bin contains the executable programs installed by the Linux distribution. It is not uncommon for this directory to hold thousands of programs. usr/local The /usr/local tree is where programs that are not included with the distribution but are intended for system-wide use are installed. Programs compiled from source code are normally installed in /usr/local/bin. On a newly installed Linux system, this tree exists, but it will be empty until the system administrator puts something in it. usr/sbin Contains more system administration programs. /usr/share /usr/share contains all the shared data used by programs in /usr/bin. This includes things such as default configuration files, icons, screen backgrounds, sound files, etc. /usr/share/doc Most packages installed on the system will include some kind of documentation. In /usr/share/doc, we will find documentation files organized by package. /var With the exception of /tmp and /home, the directories we have looked at so far remain relatively static, that is, their contents don’t change. The /var directory tree is where data that is likely to change is stored. Various databases, spool files, user mail, etc. are located here. var/long /var/log contains log files, records of various system activity. These are important and should be monitored from time to time. The most useful ones are /var/log/messages and /var/log/syslog.Note: that for security reasons on some systems only the superuser may view log files. Chapter 4 Manipulating Files and Directories At this point, we are ready for some real work! This chapter will introduce the following commands: cp – Copy files and directories mv – Move/rename files and directories mkdir – Create directories rm – Remove files and directories ln – Create hard and symbolic links How could we copy all the HTML files from one directory to another but only copy files that do not exist in the destination directory or are newer than the versions in the destination directory? It’s pretty hard with a file manager but pretty easy with the command line. $ cp -u *.html destination Wildcards Using wildcards (which is also known as globbing) allows us to select filenames based on patterns of characters. Wildcard Meaning * Matches any characters ? Matches any single character [characters] Matches any character that is a member of the set characters [!characters] Matches any character that is not a member of the set characters [[:class:]] Matches any character that is a member of the specified class Commonly Used Character Classes Charater Class Meaning [:alnum:] Matches any alphanumeric character [:alpha:] Matches any alphabetic character [:digit:] Matches any numeral [:lower:] Matches any lowercase letter [:upper:] Matches any uppercase letter Using wildcards makes it possible to construct sophisticated selection criteria for filenames. Wildcard Examples Pattern Match * All files g* Any file beginning with “g” b*.txt Any file beginning with “b” followed by any characters and ending with “.txt” Data??? Any file beginning with “Data” followed by exactly three characters [abc]* Any file beginning with either an “a,” a “b,” or a “c” BACKUP.[0-9][0-9][0-9] Any file beginning with “BACKUP.” followed by exactly three numerals [[:upper:]]* Any file beginning with an uppercase letter [![:digit:]]* Any file not beginning with a numeral *[[:lower:]123] Any file ending with a lowercase letter or the numerals “1,” “2,” or “3” Wildcards can be used with any command that accepts filenames as arguments. Character Ranges If you are coming from another Unix-like environment or have been reading some other books on this subject, you may have encountered the [A-Z] and [a-z] character range notations. These are traditional Unix notations and worked in older versions of Linux as well. They can still work, but you have to be careful with them because they will not produce the expected results unless properly configured. For now, you should avoid using them and use character classes instead. mkdir - Create Directories The mkdir command is used to create directories. It works like this: $ mkdir directory... A note on notation: When three periods follow an argument in the description of a command (as above), it means that the argument can be repeated, thus the following command: $ mkdir dir1 would create a single directory named dir1, while the following: $ mkdir dir1 dir2 dir3 would create three directories named dir1, dir2, and dir3. cp – Copy Files and Directories The cp command copies files or directories. It can be used two different ways. The following: $ cp item1 item2 copies the single file or directory item1 to the file or directory item2 and the following: $ cp item... directory copies multiple items (either files or directories) into a directory. Useful Options and Examples Options Option Long Option Meaning -a --archive Copy the files and directories and all of their attributes, including ownerships and permissions. Normally, copies take on the default attributes of the user performing the copy. -i --interactive Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, cp will silently (meaning there will be no warning) overwrite files. -r --recursive Recursively copy directories and their contents. This option (or the -a option) is required when copying directories. -u --update -v --verbose Display informative messages as the copy is performed. Examples Command Result cp file1 file1 Copy file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created cp -i file1 file2 Same as previous command, except that if file2 exists, the user is prompted before it is overwritten. cp file1 file2 dir1 Copy file1 and file2 into directory dir1. The directory dir1 must already exist. cp dir1/* dir2 Using a wildcard, copy all the files in dir1 into dir2. The directory dir2 must already exist. cp -r dir1 dir2 Copy the contents of directory dir1 to directory dir2. If directory dir2 does not exist, it is created and, after the copy, will contain the same contents as directory dir1.If directory dir2 does exist, then directory dir1 (and its contents) will be copied into dir2. mv – Move and Rename Files The mv command performs both file moving and file renaming, depending on how it is used. In either case, the original filename no longer exists after the operation. mv is used in much the same way as cp, as shown here: $ mv item1 item2 to move or rename the file or directory item1 to item2 or: $ mv item... directory to move one or more items from one directory to another. Useful Options and Examples Options Option Long Option Meaning -i --interact Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, mv will silently overwrite files. -u --update When moving files from one directory to another, only move files that either don’t exist, or are newer than the existing corresponding files in the destination directory. -v --verbose Display informative messages as the move is performed. rm – Remove Files and Directories The rm command is used to remove (delete) files and directories, as shown here: $ rm item... where item is one or more files or directories. Be Careful with rm! Unix-like operating systems such as Linux do not have an undelete command. Once you delete something with rm, it’s gone. Linux assumes you’re smart and you know what you’re doing. Be particularly careful with wildcards. Consider this classic example. Let’s say you want to delete just the HTML files in a directory. To do this, you type the following: rm .html This is correct, but if you accidentally place a space between the and the .html like so: rm * .html the rm command will delete all the files in the directory and then complain that there is no file called .html. Here is a useful tip: whenever you use wildcards with rm (besides carefully checking your typing!), test the wildcard first with ls. This will let you see the files that will be deleted. Then press the up arrow key to recall the command and replace ls with rm. Options Option Long Option Meaning -i --interactive Before deleting an existing file, prompt the user for confirmation. If this option is not specified, rm will silently delete files. -r --recursive Recursively delete directories. This means that if a directory being deleted has subdirectories, delete them too. To delete a directory, this option must be specified. -f --force Ignore nonexistent files and do not prompt. This overrides the –interactive option. -v --verbose Display informative messages as the deletion is performed. ln – Create Links The ln command is used to create either hard or symbolic links. It is used in one of two ways. The following creates a hard link: $ ln file link The following creates a symbolic link: $ ln -s file link to create a symbolic link where item is either a file or a directory. Hard Links y default, every file has a single hard link that gives the file its name. When we create a hard link, we create an additional directory entry for a file. Hard links have two important limitations: A hard link cannot reference a file outside its own file system. This means a link cannot reference a file that is not on the same disk partition as the link itself. A hard link may not reference a directory. A hard link is indistinguishable from the file itself. Unlike a symbolic link, when we list a directory containing a hard link we will see no special indication of the link. When a hard link is deleted, the link is removed but the contents of the file itself continue to exist (that is, its space is not deallocated) until all links to the file are deleted. It is important to be aware of hard links because you might encounter them from time to time, but modern practice prefers symbolic links. Symbolic Links Symbolic links were created to overcome the limitations of hard links. Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory. In this regard, they operate in much the same way as a Windows shortcut, though of course they predate the Windows feature by many years. A file pointed to by a symbolic link, and the symbolic link itself are largely indistinguishable from one another. For example, if we write something to the symbolic link, the referenced file is written to. However when we delete a symbolic link, only the link is deleted, not the file itself. If the file is deleted before the symbolic link, the link will continue to exist but will point to nothing. In this case, the link is said to be broken. In many implementations, the ls command will display broken links in a distinguishing color, such as red, to reveal their presence. Chapter 5 Working with Commands type – Indicate how a command name is interpreted which – Display which executable program will be executed help – Get help for shell builtins man – Display a command’s manual page apropos – Display a list of appropriate commands info – Display a command’s info entry whatis – Display one-line manual page descriptions alias – Create an alias for a command What Exactly Are Commands? A command can be one of four different things: An executable program like all those files we saw in /usr/bin. Within this category, programs can be compiled binaries such as programs written in C and C++, or programs written in scripting languages such as the shell, Perl, Python, Ruby, and so on. A command built into the shell itself. bash supports a number of commands internally called shell builtins. The cd command, for example, is a shell builtin. A shell function. Shell functions are miniature shell scripts incorporated into the environment. We will cover configuring the environment and writing shell functions in later chapters, but for now, just be aware that they exist. An alias. Aliases are commands that we can define ourselves, built from other commands. Identifying Commands It is often useful to know exactly which of the four kinds of commands is being used and Linux provides a couple of ways to find out. type – Display a Command’s Type The type command is a shell builtin that displays the kind of command the shell will execute, given a particular command name. It works like this: $ type command where “command” is the name of the command we want to examine. Here are some ex- amples: $ type type type is a shell builtin $ type ls ls is aliased to &#39;ls --color=tty&#39; $ type cp cp is /bin/cp which – Display an Executable’s Location Sometimes there is more than one version of an executable program installed on a system. While this is not common on desktop systems, it’s not unusual on large servers. To determine the exact location of a given executable, the which command is used. [me@linuxbox ~]$ which ls /bin/ls which only works for executable programs, not builtins nor aliases that are substitutes for actual executable programs. Getting a Command’s Documentation bash has a built-in help facility available for each of the shell builtins. To use it, type “help” followed by the name of the shell builtin. $ help cd cd: cd [-L|[-P [-e]] [-@]] [dir] Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option &#39;cdable_vars&#39; is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed: resolve symbolic links in DIR after processing instances of &#39;..&#39; -P use the physical directory structure without following symbolic links: resolve symbolic links in DIR before processing instances of &#39;..&#39; -e if the -P option is supplied, and the current working directory cannot be determined successfully, exit with a non-zero status -@ on systems that support it, present a file with extended attributes as a directory containing the file attributes The default is to follow symbolic links, as if &#39;-L&#39; were specified. &#39;..&#39; is processed by removing the immediately previous pathname component back to a slash or the beginning of DIR. Exit Status: Returns 0 if the directory is changed, and if $PWD is set successfully when -P is used; non-zero otherwise. A note on notation: When square brackets appear in the description of a command’s syntax, they indicate optional items. A vertical bar character indicates mutually exclusive items. In the case of the cd command above: cd [-L|[-P[-e]]] [dir] This notation says that the command cd may be followed optionally by either a “-L” or a “-P” and further, if the “-P” option is specified the “-e” option may also be included followed by the optional argument “dir.” –help – Display Usage Information Many executable programs support a “–help” option that displays a description of the command’s supported syntax and options. For example: $ mkdir --help Usage: mkdir [OPTION]... DIRECTORY... Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z set SELinux security context of each created directory to the default type --context[=CTX] like -Z, or if CTX is specified then set the SELinux or SMACK security context to CTX --help display this help and exit --version output version information and exit GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt; Full documentation at: &lt;https://www.gnu.org/software/coreutils/mkdir&gt; or available locally via: info &#39;(coreutils) mkdir invocation&#39; Creating Our Own Commands with alias Check is alias already exists Ex. type test Make alias command: alias name='string' Ex. alias foo='cd home; ls; cd -' Create Alias: $ alias foo=&#39;cd ~/Desktop; ls; cd -&#39; Remove Alias: $ unalias foo View all existing alias: $ alias alias egrep=&#39;egrep --color=auto&#39; alias fgrep=&#39;fgrep --color=auto&#39; alias grep=&#39;grep --color=auto&#39; alias l=&#39;ls -CF&#39; alias la=&#39;ls -A&#39; alias ll=&#39;ls -alF&#39; alias ls=&#39;ls --color=auto&#39; Chapter 6 Redirection In this lesson we are going to unleash what may be the coolest feature of the command line. It’s called I/O redirection. The “I/O” stands for input/output and with this facility we can redirect the input and output of commands to and from files, as well as connect multiple commands together into powerful command pipelines. To show off this facility, we will introduce the following commands: cat – Concatenate files sort – Sort lines of text uniq – Report or omit repeated lines grep – Print lines matching a pattern wc – Print newline, word, and byte counts for each file head – Output the first part of a file tail – Output the last part of a file tee – Read from standard input and write to standard output and files Keeping with the Unix theme of “everything is a file,” programs such as ls actually send their results to a special file called standard output (often expressed as stdout) and their status messages to another file called standard error (stderr). By default, both standard output and standard error are linked to the screen and not saved into a disk file. Redirecting Standard Output we use the &gt; redirection operator followed by the name of the file. $ ls -l path &gt; file Example: $ ls -l ~/Desktop &gt; ls-output.txt Append to an output file using &gt;&gt;, for example: $ ls -l path &gt;&gt; ls-output.txt $ ls -l path &gt;&gt; ls-output.txt $ ls -l ls-output.txt -rm-rm-r-- 1 me me 503636 2018-02-01 15:45 ls-output.txt Redirecting Standard Error standard input, output and error, the shell references them internally as file descriptors 0, 1, and 2, respectively $ ls -l /bin/usr 2&gt; ls-error.txt The file descriptor “2” is placed immediately before the redirection operator to perform the redirection of standard error to the file ls-error.txt. Redirecting Standard Output and Standard Error to One File $ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 Notice that the order of the redirections is significant. The redirection of stan- dard error must always occur after redirecting standard output or it doesn’t work. The following example redirects standard error to the file ls-output.txt: ls-output.txt 2&gt;&amp;1 However, if the order is changed to the following, standard error is directed to the screen. 2&gt;&amp;1 &gt;ls-output.txt Recent versions of bash provide a second, more streamlined method for performing this combined redirection shown here: $ ls -l /bin/usr &amp;&gt; ls-output.txt In this example, we use the single notation &amp;&gt; to redirect both standard output and standard error to the file ls-output.txt. We can also append the standard output and standard error streams to a single file like so: $ ls -l /bin/usr &amp;&gt;&gt; ls-output.txt Disposing of Unwanted Output Sometimes “silence is golden,” and we don’t want output from a command, we just want to throw it away. To suppress error messages from a command, we do this: $ ls -l path 2&gt; /dev/null /dev/null In Unix Culture The bit bucket is an ancient Unix concept and because of its universality, it has appeared in many parts of Unix culture. When someone says he/she is sending your comments to /dev/null, now you know what it means. Redirecting Standard Input cat – Concatenate Files The cat command reads one or more files and copies them to standard output like so: $ cat ls-output.txt Join multiple files: $ cat movie.mpeg.0* &gt; movie.mpeg Pipelines Using the pipe operator | (vertical bar), the standard output of one command can be piped into the standard input of another. $ command1 | command2 $ ls -l /usr/bin | less Filters Pipelines are often used to perform complex operations on data. It is possible to put several commands together into a pipeline. Frequently, the commands used this way are referred to as filters. Filters take input, change it somehow, and then output it. $ ls /bin /usr/bin | sort | less uniq - Report or Omit Repeated Lines The uniq command is often used in conjunction with sort. uniq accepts a sorted list of data from either standard input or a single filename argument (see the uniq man page for details) and, by default, removes any duplicates from the list. $ ls /bin /usr/bin | sort | uniq | less If we want to see the list of duplicates instead, we add the “-d” option to uniq like so: $ ls /bin /usr/bin | sort | uniq -d | less wc – Print Line, Word, and Byte Counts The wc (word count) command is used to display the number of lines, words, and bytes contained in files. Here’s an example: $ wc ls-output.txt 7902 64566 503634 ls-output.txt In this case, it prints out three numbers: lines, words, and bytes contained in ls-output.txt. The “-l” option limits its output to only report lines. Adding it to a pipeline is a handy way to count things. To see the number of items we have in our sorted list, we can do this: $ ls /bin /usr/bin | sort | uniq | wc -l 2728 grep – Print Lines Matching a Pattern grep is a powerful program used to find text patterns within files. It’s used like this: grep pattern [file...] There are a couple of handy options for grep: -i, which causes grep to ignore case when performing the search (normally searches are case sensitive) -v, which tells grep to print only those lines that do not match the pattern. head / tail – Print First / Last Part of Files The head command prints the first ten lines of a file, and the tail command prints the last ten lines. By default, both commands print ten lines of text, but this can be adjusted with the -n option. $ head -n 4 ls-output.txt total 16 -rw-rw-r-- 1 rkelly rkelly 51 Feb 1 21:24 ls-error.txt -rw-rw-r-- 1 rkelly rkelly 0 Feb 1 22:16 ls-output.txt drwxrwxr-x 2 rkelly rkelly 4096 Feb 1 20:50 temp_one $ tail -n 4 ls-output.txt -rw-rw-r-- 1 rkelly rkelly 0 Feb 1 22:16 ls-output.txt drwxrwxr-x 2 rkelly rkelly 4096 Feb 1 20:50 temp_one drwxrwxr-x 2 rkelly rkelly 4096 Feb 1 20:50 temp_two drwxrwxr-x 26 rkelly rkelly 4096 Feb 1 21:57 year_dirs These can be used in pipelines as well: $ ls /usr/bin | tail -n 5 zipsplit zjsdecode zless zmore znew tail has an option which allows us to view files in real time. This is useful for watching the progress of log files as they are being written. Using the “-f” option, tail continues to monitor the file, and when new lines are appended, they immediately appear on the display. This continues until we press Ctrl-c. tee – Read from Stdin and Output to Stdout and Files he tee program reads standard input and copies it to both standard output (allowing the data to continue down the pipeline) and to one or more files. This is useful for capturing a pipeline’s contents at an intermediate stage of processing. $ ls /usr/bin | tee ls.txt | grep zip Chapter 7 See the World as the Shell Sees It 7.0.1 Expansion Each time we type a command and press the Enter key, bash performs several substitutions upon the text before it carries out our command. $ echo This is a test This is a test $ echo * Desktop Documents ls-output.txt Music Pictures Public Templates Videos So what just happened? Why didn’t echo print *? As we recall from our work with wildcards, the * character means match any characters in a filename, but what we didn’t see in our original discussion was how the shell does that. The simple answer is that the shell expands the * into something else (in this instance, the names of the files in the current working directory) before the echo command is executed. When the Enter key is pressed, the shell automatically expands any qualifying characters on the command line before the command is carried out, so the echo command never saw the *, only its expanded result. Knowing this, we can see that echo behaved as expected. 7.0.1.1 Pathname Expansion The mechanism by which wildcards work is called pathname expansion. Given a home directory that looks like this: $ ls Desktop ls-output.txt Pictures Templates Documents Music we could carry out the following expansions: $ echo D* Desktop Documents and this: $ echo *s Documents Pictures Templates Videos or even this: $ echo [[:upper:]]* Desktop Documents Music Pictures Public Templates Videos and looking beyond our home directory, we could do this: $ echo /usr/*/share /usr/kerberos/share /usr/local/share Pathname Expansion of Hidden Files As we know, filenames that begin with a period character are hidden. Pathname expansion also respects this behavior. An expansion such as the following does not reveal hidden files. echo It might appear at first glance that we could include hidden files in an expansion by starting the pattern with a leading period, like this: echo . It almost works. However, if we examine the results closely, we will see that the names . and .. will also appear in the results. Because these names refer to the current working directory and its parent directory, using this pattern will likely produce an incorrect result. We can see this if we try the following command: ls -d .* | less To better perform pathname expansion in this situation, we have to employ a more specific pattern. echo .[!.]* This pattern expands into every filename that begins with only one period followed by any other characters. This will work correctly with most hidden files (though it still won’t include filenames with multiple leading periods). The ls command with the -A option (“almost all”) will provide a correct listing of hidden files. ls -A 7.0.1.2 Tilde Expansion (~) As we may recall from our introduction to the cd command, the tilde character (~) has a special meaning. $ echo ~ /home/me 7.0.1.3 Arithmetic Expansion The shell allows arithmetic to be performed by expansion. This allows us to use the shell prompt as a calculator. $ echo $((2 + 2)) 4 Arithmetic expansion uses the following form: $((expression)) where expression is an arithmetic expression consisting of values and arithmetic operators. Arithmetic expansion supports only integers (whole numbers, no decimals) but can perform quite a number of different operations. $ echo Five divided by two equals $((5/2)) Five divided by two equals 2 7.0.1.4 Brace Expansion Perhaps the strangest expansion is called brace expansion. With it, we can create multiple text strings from a pattern containing braces. Here’s an example: $ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back $ echo Number_{1..5} Number_1 Number_2 Number_3 Number_4 Number_5 $ echo {01..15} 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 echo {001..15} 001 002 003 004 005 006 007 008 009 010 011 012 013 014 015 $ echo {Z..A} Z Y X W V U T S R Q P O N M L K J I H G F E D C B A $ echo a{A{1,2},B{3,4}}b aA1b aA2b aB3b aB4b So, what is this good for? $ mkdir {2007..2009}-{01..12} $ ls 2007-01 2007-07 2008-01 2008-07 2009-01 2009-07 2007-02 2007-08 2008-02 2008-08 2009-02 2009-08 2007-03 2007-09 2008-03 2008-09 2009-03 2009-09 2007-04 2007-10 2008-04 2008-10 2009-04 2009-10 2007-05 2007-11 2008-05 2008-11 2009-05 2009-11 2007-06 2007-12 2008-06 2008-12 2009-06 2009-12 7.0.1.5 Parameter Expansion the variable named USER contains our username. To invoke parameter expansion and reveal the contents of USER we would do this: $ echo $USER me To see a list of available variables, try this: $ printenv | less 7.0.1.6 Command Substitution Command substitution allows us to use the output of a command as an expansion. $ echo $(ls) Desktop Documents ls-output.txt Music Pictures Public Templates Videos One of my favorites goes something like this: $ ls -l $(which cp) -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp Here we passed the results of which cp as an argument to the ls command, thereby getting the listing of the cp program without having to know its full pathname. We are not limited to just simple commands. Entire pipelines can be used (only partial output is shown here): $ file $(ls -d /usr/bin/* | grep zip) /usr/bin/bunzip2: symbolic link to &#39;bzip2&#39; In this example, the results of the pipeline became the argument list of the file command. There is an alternate syntax for command substitution in older shell programs that is also supported in bash. It uses backquotes instead of the dollar sign and parentheses. $ ls -l `which cp` -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp 7.0.2 Quoting The shell provides a mechanism called quoting to selectively suppress unwanted expansions. 7.0.2.1 Double Quotes The first type of quoting we will look at is double quotes. If we place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters. The exceptions are $,  (backslash), and ` (back-quote). This means that word-splitting, pathname expansion, tilde expansion, and brace expansion are suppressed, but parameter expansion, arithmetic expansion, and command substitution are still carried out. Using double quotes, we can cope with filenames containing embedded spaces. $ ls -l two words.txt ls: cannot access two: No such file or directory ls: cannot access words.txt: No such file or directory By using double quotes, we stop the word-splitting and get the desired result; further, we can even repair the damage. $ ls -l &quot;two words.txt&quot; -rw-rw-r-- 1 me me 18 2016-02-20 13:03 two words.txt $ mv &quot;two words.txt&quot; two_words.txt Remember, parameter expansion, arithmetic expansion, and command substitution still take place within double quotes. $ echo &quot;$USER $((2+2)) $(cal)&quot; me 4 February 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 7.0.2.2 Single Quotes If we need to suppress all expansions, we use single quotes. Here is a comparison of unquoted, double quotes, and single quotes: $ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER text /home/me/ls-output.txt a b foo 4 me $ echo &quot;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&quot; text ~/*.txt {a,b} foo 4 me $ echo &#39;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&#39; text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER 7.0.2.3 Escaping Characters Sometimes we want to quote only a single character. To do this, we can precede a character with a backslash, which in this context is called the escape character. Often this is done inside double quotes to selectively prevent an expansion. $ echo &quot;The balance for user $USER is: \\$5.00&quot; The balance for user me is: $5.00 Chapter 8 Advanced Keyboard Tricks clear – Clear the screen history – Display the contents of the history list Chapter 9 Permissions In this chapter we will look at this essential part of system security and introduce the following commands: id – Display user identity chmod – Change a file’s mode umask – Set the default file permissions su – Run a shell as another user sudo – Execute a command as another user chown – Change a file’s owner chgrp – Change a file’s group ownership passwd – Change a user’s password 9.0.1 Owners, Group Members, and Everybody Else When we were exploring the system in Chapter 3, we may have encountered a problem when trying to examine a file such as /etc/shadow: $ file /etc/shadow /etc/shadow: regular file, no read permission $ less /etc/shadow /etc/shadow Permission denied The reason for this error message is that, as regular users, we do not have permission to read this file. In the Unix security model, a user may own files and directories. When a user owns a file or directory, the user has control over its access. Users can, in turn, belong to a group consisting of one or more users who are given access to files and directories by their owners. In addition to granting access to a group, an owner may also grant some set of access rights to everybody, which in Unix terms is referred to as the world. To find out information about your identity, use the id command. $ id uid=500(me) gid=500(me) groups=500(me) User accounts are defined in the /etc/passwd file and groups are defined in the /etc/group file. When user accounts and groups are created, these files are modified along with /etc/shadow which holds information about the user’s password. For each user account, the /etc/passwd file defines the user (login) name, uid, gid, account’s real name, home directory, and login shell. If we examine the contents of /etc/passwd and /etc/group, we notice that besides the regular user accounts, there are accounts for the superuser (uid 0) and various other system users. While many Unix-like systems assign regular users to a common group such as “users,” modern Linux practice is to create a unique, single-member group with the same name as the user. This makes certain types of permission assignment easier. 9.0.2 Reading, Writing, and Executing Access rights to files and directories are defined in terms of read access, write access, and execution access. If we look at the output of the ls command, we can get some clue as to how this is implemented: $ &gt; foo.txt $ ls -l foo.txt -rw-rw-r-- 1 me me 0 2016-03-06 14:52 foo.txt The first 10 characters of the listing are the file attributes. The first of these characters is the file type. File Types Attribute File Type - A regular file. d A directory. l A symbolic link. Notice that with symbolic links, the remaining file attributes are always “rwxrwxrwx” and are dummy values. The real file attributes are those of the file the symbolic link points to. c A character special file. This file type refers to a device that handles data as a stream of bytes, such as a terminal or /dev/null. b A block special file. This file type refers to a device that handles data in blocks, such as a hard drive or DVD drive. The remaining nine characters of the file attributes, called the file mode, represent the read, write, and execute permissions for the file’s owner, the file’s group owner, and everybody else. Owner Group World rwx rwx rwx Permission Attributes Attribute Files Directories r Allows a file to be opened and read. Allows a directory’s contents to be listed if the execute attribute is also set. w Allows a file to be written to or truncated, however this attribute does not allow files to be renamed or deleted. The ability to delete or rename files is determined by directory attributes. Allows files within a directory to be created, deleted, and renamed if the execute attribute is also set. x Allows a file to be treated as a program and executed. Program files written in scripting languages must also be set as readable to be executed. Allows a directory to be entered, e.g., cd directory. Permission Attribute Examples File Attribute Meaning -rwx------ A regular file that is readable, writable, and executable by the file’s owner. No one else has any access. -rw------- A regular file that is readable and writable by the file’s owner. No one else has any access. -rw-r--r-- A regular file that is readable and writable by the file’s owner. Members of the file’s owner group may read the file. The file is world-readable. -rwxr-xr-x A regular file that is readable, writable, and executable by the file’s owner. The file may be read and executed by everybody else. -rw-rw---- A regular file that is readable and writable by the file’s owner and members of the file’s group owner only. lrwxrwxrwx A symbolic link. All symbolic links have “dummy” permissions. The real permissions are kept with the actual file pointed to by the symbolic link. drwxrwx--- A directory. The owner and the members of the owner group may enter the directory and create, rename and remove files within the directory. drwxr-x--- A directory. The owner may enter the directory and create, rename, and delete files within the directory. Members of the owner group may enter the directory but cannot create, delete, or rename files. 9.0.2.1 chmod – Change File Mode To change the mode (permissions) of a file or directory, the chmod command is used. Be aware that only the file’s owner or the superuser can change the mode of a file or directory. chmod supports two distinct ways of specifying mode changes: octal number representation, or symbolic representation. File Modes in Binary and Octal Octal Binary File Mode 0 000 --- 1 001 --x 2 010 -w- 3 011 -wx 4 100 r-- 5 101 r-x 6 110 rw- 7 111 rwx By using three octal digits, we can set the file mode for the owner, group owner, and world. $ &gt; foo.txtx $ ls -l foo.txt -rw-rw-r-- 1 me me 0 2016-03-06 14:52 foo.txt $ chmod 600 foo.txt $ ls -l foo.txt -rw------- 1 me me 0 2016-03-06 14:52 foo.txt By passing the argument “600,” we were able to set the permissions of the owner to read and write while removing all permissions from the group owner and world. chmod also supports a symbolic notation for specifying file modes. Symbolic notation is divided into three parts. Who the change will affect Which operation will be performed What permission will be set. References Shotts, William. 2019. The Linux Command Line. Fifth Internet Edition. No Starch Press. http://linuxcommand.org/tlcl.php. "]]
